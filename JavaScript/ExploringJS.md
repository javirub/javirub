# Done

## I Background

1 Before you buy the book
   - 1.1 About the content
   - 1.2 Previewing and buying this book
   - 1.3 About the author
   - 1.4 Acknowledgements

2 FAQ: Book and Supplementary Material
   - 2.1 How to read this book
   - 2.2 I own a digital version
   - 2.3 I own the print version (“JavaScript for impatient programmers”)
   - 2.4 Notations and conventions

3 Why JavaScript?
   - 3.1 The cons of JavaScript
   - 3.2 The pros of JavaScript
   - 3.3 Pro and con of JavaScript: innovation

4 The Nature of JavaScript
   - 4.1 JavaScript’s influences
   - 4.2 The nature of JavaScript
   - 4.3 Tips for getting started with JavaScript

5 History and Evolution of JavaScript
   - 5.1 How JavaScript was created
   - 5.2 Standardization: JavaScript vs. ECMAScript
   - 5.3 Timeline of ECMAScript versions
   - 5.4 Evolving JavaScript: TC39 (Ecma Technical Committee 39)
   - 5.5 The TC39 process for proposed ECMAScript features
   - 5.6 How to not break the web while changing JavaScript
   - 5.7 FAQ: ECMAScript and TC39

6 New JavaScript Features
   - 6.1 New in ECMAScript 2024
   - 6.2 New in ECMAScript 2023
   - 6.3 New in ECMAScript 2022
   - 6.4 New in ECMAScript 2021
   - 6.5 New in ECMAScript 2020
   - 6.6 New in ECMAScript 2019
   - 6.7 New in ECMAScript 2018
   - 6.8 New in ECMAScript 2017
   - 6.9 New in ECMAScript 2016
   - 6.10 Source of this chapter

7 FAQ: JavaScript
   - 7.1 What are good references for JavaScript?
   - 7.2 How do I find out what JavaScript features are supported where?
   - 7.3 Where can I look up what features are planned for JavaScript?
   - 7.4 Why does JavaScript fail silently so often?
   - 7.5 Why can’t we clean up JavaScript, by removing quirks and outdated features?
   - 7.6 How can I quickly try out a piece of JavaScript code?

## II First Steps

8 Using JavaScript: The Big Picture
   - 8.1 What are you learning in this book?
   - 8.2 The structure of browsers and Node.js
   - 8.3 JavaScript references
   - 8.4 Further reading

9 Syntax
   - 9.1 An overview of JavaScript’s syntax
   - 9.2 (Advanced)
   - 9.3 Hashbang lines (Unix shell scripts)
   - 9.4 Identifiers
   - 9.5 Statement vs. expression
   - 9.6 Ambiguous syntax
   - 9.7 Semicolons
   - 9.8 Automatic semicolon insertion (ASI)
   - 9.9 Semicolons: best practices
   - 9.10 Strict mode vs. sloppy mode


# TODO


10 Consoles: Interactive JavaScript Command Lines
   - 10.1 Trying out JavaScript code
   - 10.2 The console.* API: printing data and more

11 Assertion API
   - 11.1 Assertions in software development
   - 11.2 How assertions are used in this book
   - 11.3 Normal comparison vs. deep comparison
   - 11.4 Quick reference: module assert

12 Getting Started with Exercises
   - 12.1 Exercises
   - 12.2 Unit tests in JavaScript

## III Variables and Values

13 Variables and Assignment
   - 13.1 let
   - 13.2 const
   - 13.3 Deciding between const and let
   - 13.4 The scope of a variable
   - 13.5 (Advanced)
   - 13.6 Terminology: static vs. dynamic
   - 13.7 Global variables and the global object
   - 13.8 Declarations: scope and activation
   - 13.9 Closures

14 Values
   - 14.1 What’s a type?
   - 14.2 JavaScript’s type hierarchy
   - 14.3 The types of the language specification
   - 14.4 Primitive values vs. objects
   - 14.5 The operators typeof and instanceof: what’s the type of a value?
   - 14.6 Classes and constructor functions
   - 14.7 Converting between types

15 Operators
   - 15.1 Making sense of operators
   - 15.2 The plus operator (+)
   - 15.3 Assignment operators
   - 15.4 Equality: == vs. ===
   - 15.5 Ordering operators
   - 15.6 Various other operators

## IV Primitive Values

16 The Non-Values undefined and null
   - 16.1 undefined vs. null
   - 16.2 Occurrences of undefined and null
   - 16.3 Checking for undefined or null
   - 16.4 The nullish coalescing operator (??) for default values [ES2020]
   - 16.5 undefined and null don’t have properties
   - 16.6 The history of undefined and null

17 Booleans
   - 17.1 Converting to boolean
   - 17.2 Falsy and truthy values
   - 17.3 Truthiness-based existence checks
   - 17.4 Conditional operator (? :)
   - 17.5 Binary logical operators: And (x && y), Or (x || y)
   - 17.6 Logical Not (!)

18 Numbers
   - 18.1 Numbers are used for both floating point numbers and integers
   - 18.2 Number literals
   - 18.3 Arithmetic operators
   - 18.4 Converting to number
   - 18.5 Error values
   - 18.6 The precision of numbers: careful with decimal fractions
   - 18.7 (Advanced)
   - 18.8 Background: floating point precision
   - 18.9 Integer numbers in JavaScript
   - 18.10 Bitwise operators
   - 18.11 Quick reference: numbers

19 Math
   - 19.1 Data properties
   - 19.2 Exponents, roots, logarithms
   - 19.3 Rounding
   - 19.4 Trigonometric Functions
   - 19.5 Various other functions
   - 19.6 Sources

20 Bigints – Arbitrary-Precision Integers [ES2020] (Advanced)
   - 20.1 Why bigints?
   - 20.2 Bigints
   - 20.3 Bigint literals
   - 20.4 Reusing number operators for bigints (overloading)
   - 20.5 The wrapper constructor BigInt
   - 20.6 Coercing bigints to other primitive types
   - 20.7 TypedArrays and DataView operations for 64-bit values
   - 20.8 Bigints and JSON
   - 20.9 FAQ: Bigints

21 Unicode – A Brief Introduction (Advanced)
   - 21.1 Code points vs. code units
   - 21.2 Encodings used in web development: UTF-16 and UTF-8
   - 21.3 Grapheme clusters – the real characters

22 Strings
   - 22.1 Cheat sheet: strings
   - 22.2 Plain string literals
   - 22.3 Access

...